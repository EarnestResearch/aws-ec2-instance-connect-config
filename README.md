# AWS EC2 Instance Connect Configuration

This package contains the EC2 instance configuration and scripts necessary to enable AWS EC2 Instance Connect.

This package does *not* include the build configuration or packaging for EC2's package repositories - such packaging is handled by the Amazon Linux maintainers.

## AuthorizedKeysCommand

The AuthorizedKeysCommand is split into two parts, both under src/opt/aws/bin/

* curl_authorized_keys, which is the entry point for sshd on an ssh call
* parse_authorized_keys, which is the main authorized keys command logic

This split is intentional - as parse takes all necessary pieces as command inputs is can be unit tested independently.  curl, however, obviously needs to curl EC2 Instance Metadata Service and so cannot be tested without mocking the actual service.

### curl_authorized_keys

The curl script is a dumb entry point and serves only to curl the relevant information from EC2 Instance Metadata Service and send it to parse.

Note that it must make several curl commands to proceed.  If it cannot do so it fast-fails to prevent blocking the ssh daemon.

An interesting part to note is that the command also queries several OCSP staples from EC2 Instance Metadata Service.
These OCSP staples are provided from the AWS EC2 Instance Connect Service to avoid needing to query each CRL or OCSP authority at ssh calltime as that would have major performance implications.
The staples are passed to and used by parse_authorized_keys to check certificate validity without the need for extra external calls.

### parse_authorized_keys

In addition to the fields required to complete all the below process, a key fingerprint may be provided.  If a key fingerprint is specified then only ssh keys found matching that fingerprint will be returned.

#### Certificate Validation

The core idea behind AWS EC2 Instance Connect is that all ssh keys vended have been trusted by AWS.  This can be verified by checking each key's signature (more on that later) and vetting the signing certificate used.

The signing certificate goes through a deep verification flow that checks:

* The CN matches the service
* The certificate trust chain can be verified up through the Amazon Trust Services Certificate Authority
* The entire certificate chain is valid - ie, none of them have been revoked

The first and second are done via standard openssl checks.  The third, however, does not query the relevant CRLs or OCSP authorities at runtime.
Instead, OCSP staples are expected to be provided by the invoker (such as curl_authorized_keys).
As OCSP staples are cryptographically sound these are considered a sufficient validity check.

#### Key Processing

The keys are expected to be presented to the script in the format

<pre>
# Key Metadata
# Key Metadata
# Key Metadata
[ssh key]
signature
</pre>

Currently, the expected metadata is, in order,

1. Expiration timestamp
2. Instance ID
3. IAM Caller
4. Request ID

Once this data has been loaded, the following checks are run:

* Has the expiration timestamp passed?
* Is the instance ID correct?
* Does the signature match the provided data?
* If a specific key fingerprint was provided to search for, does this key match that fingerprint?

The signature is specifically expected to be for the *entire* key blob - all metadata entries plus the ssh key.  It should have been generated by the AWS EC2 Instance Connect service's private key, which is verified using the vetted signing certificate.

If all of these checks pass then the key will be presented to the ssh daemon.  Otherwise, it will be ignored and the next key will be processed.

Any time a key is provided to the ssh daemon it will be logged to the system authpriv log for auditing purposes.

## Testing

As parse_authorized_keys requires a valid certificate, CA, and OCSP staples, unit testing is a somewhat involved process.

Fortunately, all of this has been automated to a convenient entry point: `bin/test/run_authorized_keys_tests.sh`.  This will

1. Invoke `bin/test/setup_certificates.sh` to generate a test CA and trust chain
2. Invoke `bin/test/generate_ocsp.sh` to generate OCSP staples for the certificates
3. Iterate over test/input/direct and test/input/unsigned and test all entries via `bin/test/test_authorized_keys.sh`, expecting the matching contents of test/expected-output

test/input/direct's contents are passed directly as-is as they are not expected to contain valid signatures.

test/input/unsigned's contents, however, are expected to get far enough in the process to (potentially) need a valid signature.  As such, signatures are generated on-the-fly using the pre-generated certificate's private key.

The structure of test/input/unsigned, rather than files, is directories to test.  The directory's contents should be in a numeric order that the test script will iterate.
Each file should have *one* test key blob to sign.
The actual test input will be the result of generating signatures for each file and constructing an imitation of the service's key bundle.

## Manual Setup

If desired, this scripting can be added to an EC2 instance for further testing.  A convenience pair of scripts - bin/make_tarball.sh and bin/configure_sshd.sh - can be used to do so.

* make_tarball will compress the contents of src for easy installation.
* configure_sshd will add an ec2-instance-connect system user and modify /etc/ssh/sshd_config to enable the relevant AuthorizedKeysCommand

Note: if you are running an instance with OpenSSH 6.9 or new installed, it is strongly encouraged that in addition to the changes configure_sshd makes you also add `%f` to the AuthorizedKeysCommand line.  This flag is not supported on older versions of OpenSSH!

## License

This library is licensed under the Apache 2.0 License.
